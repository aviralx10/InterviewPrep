  //BRUTE FORCE SOLUTION IS TO TAKE ALL SUBSETS AND CHECK EACH SUBSET IF IT HAS EQUAL NUMBER OF 1 AND 0 {TC:O(N*2^N)}

//SOLUTION 1: OPTIMISED APPROACH IS TO LOOK at each index .. if A[i] is 0 make it as sum=-1 so as to make the total sum=0 if number of 1s and 0s are equal. 

int largestsubarray(vector<int> A){
int sum=0;
int max_size=-1;
  for(int i=0;i<n-1;i++){
    if(A[i]==0){sum=-1;}
    else sum=1;
    for(int j=i+1;j<n;j++){
      if(A[j]==0) {sum+=-1;}
      else sum+=1;
      if(sum==0 && max_size>j-i+1){                     //MAX_SIZE STORES THE LARGEST SUBARRAY WITH EQUAL NUMBER OF 0'S AND 1'S
        max_size=j-i+1;
        starting index=i;
      }
    }
  
  }
  return max_size;
}

//SOLUTION 2: USING HASH TABLES


    int sumleft[n]; 
  
    // For min and max values in sumleft[] 
  
    int min, max; 
    int i; 
  
    // Fill sumleft array and get min and max 
    // values in it.  Consider 0 values in arr[] 
    // as -1 
  
    sumleft[0] = ((arr[0] == 0) ? -1 : 1); 
    min = arr[0]; 
    max = arr[0]; 
    for (i = 1; i < n; i++) { 
        sumleft[i] = sumleft[i - 1] 
                     + ((arr[i] == 0) ? -1 : 1); 
        if (sumleft[i] < min) 
            min = sumleft[i]; 
        if (sumleft[i] > max) 
            max = sumleft[i]; 
    } 
  
    // Now calculate the max value of j - i such 
    // that sumleft[i] = sumleft[j]. The idea is 
    // to create a hash table to store indexes of all 
    // visited values. 
    // If you see a value again, that it is a case of 
    // sumleft[i] = sumleft[j]. Check if this j-i is 
    // more than maxsize. 
    // The optimum size of hash will be max-min+1 as 
    // these many different values of sumleft[i] are 
    // possible. Since we use optimum size, we need 
    // to shift all values in sumleft[] by min before 
    // using them as an index in hash[]. 
  
    int hash[max - min + 1]; 
  
    // Initialize hash table 
  
    for (i = 0; i < max - min + 1; i++) 
        hash[i] = -1; 
  
    for (i = 0; i < n; i++) { 
        // Case 1: when the subarray starts from 
        // index 0 
  
        if (sumleft[i] == 0) { 
            maxsize = i + 1; 
            startindex = 0; 
        } 
  
        // Case 2: fill hash table value. If already 
        // filled, then use it 
  
        if (hash[sumleft[i] - min] == -1) 
            hash[sumleft[i] - min] = i; 
        else { 
            if ((i - hash[sumleft[i] - min]) > maxsize) { 
                maxsize = i - hash[sumleft[i] - min]; 
                startindex = hash[sumleft[i] - min] + 1; 
            } 
        } 
    } 
